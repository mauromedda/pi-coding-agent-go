// ABOUTME: Cumulative token and cost tracker with budget alerts
// ABOUTME: Thread-safe; tracks per-call and session totals for cost dashboard

package telemetry

import "sync"

// Alert represents a budget threshold event.
type Alert struct {
	Type       string  // "warning" or "limit"
	Message    string
	CurrentUSD float64
	BudgetUSD  float64
	Percentage float64
}

// CallRecord stores token usage for a single LLM call.
type CallRecord struct {
	Model        string
	InputTokens  int
	OutputTokens int
	CostUSD      float64
}

// Summary returns current session totals.
type Summary struct {
	TotalInputTokens  int
	TotalOutputTokens int
	TotalCostUSD      float64
	CallCount         int
	BudgetUSD         float64
	BudgetUsedPct     float64
	Alerts            []Alert
}

// Tracker accumulates token usage and cost across a session.
type Tracker struct {
	mu            sync.Mutex
	calls         []CallRecord
	totalInput    int
	totalOutput   int
	totalCostUSD  float64
	budgetUSD     float64 // 0 = no limit
	warnPct       int     // warn at this % of budget; default 80
	alerts        []Alert
	onAlert       func(Alert) // optional callback
	warnTriggered bool
	limitTriggered bool
}

// NewTracker creates a tracker with optional budget and warning percentage.
// budgetUSD=0 disables budget alerts. warnPct defaults to 80 if <= 0.
func NewTracker(budgetUSD float64, warnPct int) *Tracker {
	if warnPct <= 0 {
		warnPct = 80
	}
	return &Tracker{
		budgetUSD: budgetUSD,
		warnPct:   warnPct,
	}
}

// SetAlertCallback sets a function called when an alert fires.
func (t *Tracker) SetAlertCallback(fn func(Alert)) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.onAlert = fn
}

// Record adds a new call record and checks budget thresholds.
// Returns any new alerts generated by this call.
func (t *Tracker) Record(model string, inputTokens, outputTokens int) []Alert {
	cost := EstimateCost(model, inputTokens, outputTokens)

	t.mu.Lock()
	defer t.mu.Unlock()

	t.calls = append(t.calls, CallRecord{
		Model:        model,
		InputTokens:  inputTokens,
		OutputTokens: outputTokens,
		CostUSD:      cost,
	})
	t.totalInput += inputTokens
	t.totalOutput += outputTokens
	t.totalCostUSD += cost

	var newAlerts []Alert

	if t.budgetUSD > 0 {
		pct := (t.totalCostUSD / t.budgetUSD) * 100

		if !t.warnTriggered && pct >= float64(t.warnPct) {
			a := Alert{
				Type:       "warning",
				Message:    "budget warning threshold reached",
				CurrentUSD: t.totalCostUSD,
				BudgetUSD:  t.budgetUSD,
				Percentage: pct,
			}
			newAlerts = append(newAlerts, a)
			t.alerts = append(t.alerts, a)
			t.warnTriggered = true
		}

		if !t.limitTriggered && pct >= 100 {
			a := Alert{
				Type:       "limit",
				Message:    "budget limit reached",
				CurrentUSD: t.totalCostUSD,
				BudgetUSD:  t.budgetUSD,
				Percentage: pct,
			}
			newAlerts = append(newAlerts, a)
			t.alerts = append(t.alerts, a)
			t.limitTriggered = true
		}
	}

	// Fire callback outside the critical path but still under lock
	// to guarantee ordering. The callback should be fast.
	if t.onAlert != nil {
		for _, a := range newAlerts {
			t.onAlert(a)
		}
	}

	return newAlerts
}

// Summary returns current session totals.
func (t *Tracker) Summary() Summary {
	t.mu.Lock()
	defer t.mu.Unlock()

	var budgetPct float64
	if t.budgetUSD > 0 {
		budgetPct = (t.totalCostUSD / t.budgetUSD) * 100
	}

	alertsCopy := make([]Alert, len(t.alerts))
	copy(alertsCopy, t.alerts)

	return Summary{
		TotalInputTokens:  t.totalInput,
		TotalOutputTokens: t.totalOutput,
		TotalCostUSD:      t.totalCostUSD,
		CallCount:         len(t.calls),
		BudgetUSD:         t.budgetUSD,
		BudgetUsedPct:     budgetPct,
		Alerts:            alertsCopy,
	}
}

// Reset clears all accumulated data but preserves budget configuration.
func (t *Tracker) Reset() {
	t.mu.Lock()
	defer t.mu.Unlock()

	t.calls = nil
	t.totalInput = 0
	t.totalOutput = 0
	t.totalCostUSD = 0
	t.alerts = nil
	t.warnTriggered = false
	t.limitTriggered = false
}
